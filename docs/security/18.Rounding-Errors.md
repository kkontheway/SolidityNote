---
title: 18.Rounding-Errors
---
# Brief Intro
在 Solidity 中，数字类型的种类有限。与许多编程语言不同，不支持浮点数。部分支持定点数，但不能分配给定点数或从定点数分配。 Solidity 中的主要数字类型是整数，其中计算的结果值始终向下舍入。

由于除法通常会产生余数，因此用整数执行除法通常需要在某种程度上缺乏精度。要了解缺乏精确性如何导致严重缺陷。

# Example-1
其中我们对提前提款收取费用，以提前提款的天数计价：

```solidity
uint256 daysEarly = withdrawalsOpenTimestamp - block.timestamp / 1 days
uint256 fee = amount / daysEarly * dailyFee
```
这样做的问题是，如果用户提前 1.99 天提现，由于 1.99 会向下舍入为 1，因此用户只需支付大约一半的预期费用。

一般来说，我们应该确保分子足够大于分母，以避免精度误差。该问题的常见解决方案是使用定点逻辑，即将整数提高到足够数量的小数，以便精度的缺乏对合约逻辑的影响最小。一个好的经验法则是将数字提高到 1e18（通常称为 WAD）。

